CLASS:: WaveLoss
summary:: Lose bits of your waves
categories:: UGens>Filters>Nonlinear
related:: Classes/Squiz

DESCRIPTION::
Uses the zero-crossings to divide an audio stream into tiny segments, and simply discards a fraction of the segments (replacing them with silence). The technique was described in a lecture by Trevor Wishart.

Parameters: the filter drops strong::drop:: out of strong::outof:: chunks. strong::mode:: can be 1 to drop chunks in a simple deterministic fashion (e.g. always dropping the first 30 out of a set of 40 segments), or 2 to drop chunks randomly but in an appropriate proportion.

CLASSMETHODS::

METHOD:: ar
argument:: in
argument:: drop
argument:: outof
argument:: mode
argument:: mul
argument:: add

METHOD:: kr
argument:: in
argument:: drop
argument:: outof
argument:: mode
argument:: mul
argument:: add


EXAMPLES::

code::
s.boot;
// Move the mouse left/right to see the gradation of the effect. 
// Move up or down to choose mode. The modes sound very different.
(
x = {
	var sig, mode;
	sig = [SinOsc.ar, PinkNoise.ar].mean;
	mode = MouseY.kr(1,2).round;
	WaveLoss.ar(sig, MouseX.kr(0, 40), 40, mode: mode, mul: 0.1);
}.play;
)
x.free;

// Plotting shows quite clearly what's going on:
(
{
	var sig;
	sig = [SinOsc.ar, PinkNoise.ar].mean;
	[sig, WaveLoss.ar(sig, 20, 40, mode: 2)];
}.plot(0.15);
)

// A stereo example, evolves over a couple of minutes - specify a breakbeat loop sample below, sounds good
b = Buffer.read(s,"sounds/amenfast.wav"); // remember to free the buffer later.
(
x = {
	var sig, mode, woo;
	sig = PlayBuf.ar(1, b.bufnum, BufRateScale.kr(b.bufnum) * 0.75, startPos: 92898, loop: 1);
	woo = {
		WaveLoss.ar(sig, 
			EnvGen.kr(Env.new([199, 199, 150, 150, 199, 250], [20, 40, 60, 60, 100]), doneAction:2)
			+ (FSinOsc.kr(0.2 + XLine.kr(0.001, [1.3, 1.7], 90), 0, 50) * XLine.kr(0.00000001, 1, 60))
			,
			200, mode: 2, mul: 0.4);
	}.dup;
	woo = (woo * 0.9) + (woo.reverse * 0.1);
}.play;
)
x.free;
b.free;
::

